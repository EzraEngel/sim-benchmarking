{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to SimBench","text":"<p>SimBench is a zero-dependency benchmarking harness for spatial simulation engines.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Type-Safe: Uses modern Python 3.12+ features.</li> <li>Concurrent: Handles IPC via subprocess module.</li> <li>Extensible: Strict interface decoupling.</li> </ul>"},{"location":"reference/configuration/","title":"Configuration","text":""},{"location":"reference/configuration/#configuration","title":"<code>configuration</code>","text":""},{"location":"reference/configuration/#configuration.SetupUI","title":"<code>SetupUI</code>","text":"<p>Represents the terminal-based UI and related methods to provide the user feedback during configuration. Because configuration and build can take around 30 seconds on moderately powered desktop, this feedback is important.</p> Source code in <code>configuration/ui.py</code> <pre><code>class SetupUI:\n    \"\"\"\n    Represents the terminal-based UI and related methods to provide the user feedback during configuration. Because\n    configuration and build can take around 30 seconds on moderately powered desktop, this feedback is important.\n    \"\"\"\n\n    welcome_message = Text(\"Welcome to the ABM Simulation Benchmark Generator\", justify=\"center\", style=\"bold green\")\n    welcome_panel = Panel(welcome_message, title=\"[bold cyan]Setup[/bold cyan]\", border_style=\"cyan\")\n    progress_columns = [\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TextColumn(\"[progress.percentage]{task.percentage:&gt;3.0f}%\"),\n        TextColumn(\"({task.completed} of {task.total})\"),\n        TimeRemainingColumn(),\n    ]\n\n    num_jobs: int\n    processes: list[Process]\n    console: Console\n    start_time: Any\n    end_time: Any\n\n    def __init__(self, num_jobs: int, processes: list[Process]) -&gt; None:\n        self.num_jobs = num_jobs\n        self.processes = processes\n        self.console = Console()\n        self.welcome()\n\n    def welcome(self) -&gt; None:\n        self.console.print(self.welcome_panel)\n        self.console.print(f\"Found [bold yellow]{self.num_jobs}[/bold yellow] benchmark scenarios to generate.\")\n\n    def poll(self) -&gt; None:\n        self.start_time = time.time()\n        with Progress(*self.progress_columns, console=self.console) as progress:\n            task = progress.add_task(\"[green]Generating scenarios...\", total=self.num_jobs)\n            completed_processes = 0\n            while completed_processes &lt; self.num_jobs:\n                for p in self.processes:\n                    if not p.is_alive():\n                        p.join()\n                        self.processes.remove(p)\n                        completed_processes += 1\n                        progress.update(task, advance=1)\n                time.sleep(0.1)\n        self.end_time = time.time()\n\n    def finish(self) -&gt; None:\n        self.console.print(\n            f\"\\n[bold green]\u2713 Successfully finished building {self.num_jobs} benchmarks in {self.end_time - self.start_time:.2f} seconds.[/bold green]\")\n</code></pre>"},{"location":"reference/configuration/#configuration.DistType","title":"<code>DistType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Distribution type.</p> Source code in <code>configuration/benchmark_setup.py</code> <pre><code>class DistType(StrEnum):\n    \"\"\" Distribution type. \"\"\"\n    UNIFORM = auto()\n    NORMAL = auto()\n</code></pre>"},{"location":"reference/configuration/#configuration.MoveType","title":"<code>MoveType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Movement tpe (static or dynamic).</p> Source code in <code>configuration/benchmark_setup.py</code> <pre><code>class MoveType(StrEnum):\n    \"\"\" Movement tpe (static or dynamic). \"\"\"\n    STATIC = auto()\n    DYNAMIC = auto()\n</code></pre>"},{"location":"reference/configuration/#configuration.LOSType","title":"<code>LOSType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Line of sight type (whether simulation supports LOS checks).</p> Source code in <code>configuration/benchmark_setup.py</code> <pre><code>class LOSType(StrEnum):\n    \"\"\" Line of sight type (whether simulation supports LOS checks). \"\"\"\n    LOS = auto()\n    NO_LOS = auto()\n</code></pre>"},{"location":"reference/configuration/#configuration.BenchmarkSetup","title":"<code>BenchmarkSetup</code>","text":"<p>This is a class that holds most of the methods and parameterization for the benchmark configuration. It defines a directory structure, and calls a series of methods to instantiate the correct objects and dump them into json files.</p> Source code in <code>configuration/benchmark_setup.py</code> <pre><code>class BenchmarkSetup:\n    \"\"\"\n    This is a class that holds most of the methods and parameterization for the benchmark configuration.\n    It defines a directory structure, and calls a series of methods to instantiate the correct objects and\n    dump them into json files.\n    \"\"\"\n    benchmark_dirs = [\n        os.path.join(\"benchmarks\", \"geometry\", \"uniform_static_no_los\"),\n        os.path.join(\"benchmarks\", \"geometry\", \"uniform_static_los\"),\n        os.path.join(\"benchmarks\", \"geometry\", \"uniform_dynamic_no_los\"),\n        os.path.join(\"benchmarks\", \"geometry\", \"uniform_dynamic_los\"),\n        os.path.join(\"benchmarks\", \"geometry\", \"normal_static_no_los\"),\n        os.path.join(\"benchmarks\", \"geometry\", \"normal_static_los\"),\n        os.path.join(\"benchmarks\", \"geometry\", \"normal_dynamic_no_los\"),\n        os.path.join(\"benchmarks\", \"geometry\", \"normal_dynamic_los\"),\n        os.path.join(\"benchmarks\", \"graphs\", \"disjoint_network\"),\n        os.path.join(\"benchmarks\", \"graphs\", \"pathfinding\"),\n        os.path.join(\"benchmarks\", \"graphs\", \"network_routing\"),\n        os.path.join(\"benchmarks\", \"graphs\", \"weapon_target_assignment\"),\n        os.path.join(\"benchmarks\", \"graphs\", \"supply_network\"),\n        os.path.join(\"benchmarks\", \"propagation\", \"radar\"),\n        os.path.join(\"benchmarks\", \"propagation\", \"threat\"),\n        os.path.join(\"benchmarks\", \"propagation\", \"contamination\")\n    ]\n\n    @staticmethod\n    def set_up_benchmark_dirs() -&gt; None:\n        \"\"\" Sets up the directory structure on the host. \"\"\"\n        for benchmark_dir in BenchmarkSetup.benchmark_dirs:\n            if not os.path.exists(benchmark_dir):\n                os.makedirs(benchmark_dir)\n\n    @staticmethod\n    def generate_geometric_benchmark_jobs(sim_size: dict[str, int], writer_args: WriterArgs) -&gt; list[WriterArgs]:\n        \"\"\"\n        Generates a list of benchmark jobs to run in parallel. Be wary of modifying the hardcoded parameters below\n        without corresponding changes to the directory structure.\n        \"\"\"\n\n        distributions = [DistType.UNIFORM, DistType.NORMAL]\n        movements = [MoveType.STATIC, MoveType.DYNAMIC]\n        los_strs = [LOSType.LOS, LOSType.NO_LOS]\n\n        job_list: list[dict[str, Any]] = []\n        # --- Write all the benchmark configs ---\n        for dist in distributions:\n            for move in movements:\n                for los in los_strs:\n                    for size_name, num_agents in sim_size.items():\n                        file_name = f\"{dist}_{move}_{los}_{size_name}.json\"\n                        file_path = os.path.join(\"benchmarks\", \"geometry\", f\"{dist}_{move}_{los}\", file_name)\n                        writer_args[\"file_path\"] = file_path\n                        writer_args[\"los\"] = los\n                        writer_args[\"dist\"] = dist\n                        writer_args[\"num_agents\"] = num_agents\n                        job_list.append(copy.deepcopy(writer_args))\n        return job_list\n\n    @staticmethod\n    def process_objects(file_path: str,\n                        random_seed: int,\n                        num_agents: int,\n                        speed: float,\n                        fov: float,\n                        view_range: float,\n                        occ_per_agent: int,\n                        scale: float,\n                        shape: str,\n                        targets_per_sensor: int,\n                        dist: DistType,\n                        los: LOSType) -&gt; None:\n        \"\"\"\n        This is the callable which is dispatched to the multiprocessing module. The scrip in __main__.py will fork\n        the process and execute this method in the child. It takes an unpacked set of writer arguments as parameters\n        which you can observe in the __main__.py file.\n        \"\"\"\n\n        # --- Set the random seed ---\n        random.seed(random_seed)\n\n        # --- Build the sensor ---\n        sensor = SphericalSectorSensor(view_range=view_range, field_of_view=fov)\n\n        # --- Build the distribution from scenario ---\n        distribution_builder = DistributionBuilder(num_agents)\n        if dist == DistType.UNIFORM:\n            distribution = distribution_builder.build_uniform_from_sensor_and_targets(sensor, targets_per_sensor)\n        elif dist == DistType.NORMAL:\n            distribution = distribution_builder.build_gauss_from_sensor_and_targets(sensor, targets_per_sensor)\n        else:\n            raise NotImplementedError\n\n        # --- Make and write the Agents ---\n        agents = [Agent.random(distribution=distribution, speed=speed, sensor=sensor) for i in range(num_agents)]\n        if los == LOSType.NO_LOS:\n            SimObject.write_objects(file_path, agents=agents)\n            return\n\n        # --- Make and write the occluders ---\n        occluders = [Occluder.random(distribution=distribution, scale=scale, shape=shape) for i in range(occ_per_agent * num_agents)]\n        SimObject.write_objects(file_path, agents=agents, occluders=occluders)\n</code></pre>"},{"location":"reference/configuration/#configuration.BenchmarkSetup.generate_geometric_benchmark_jobs","title":"<code>generate_geometric_benchmark_jobs(sim_size, writer_args)</code>  <code>staticmethod</code>","text":"<p>Generates a list of benchmark jobs to run in parallel. Be wary of modifying the hardcoded parameters below without corresponding changes to the directory structure.</p> Source code in <code>configuration/benchmark_setup.py</code> <pre><code>@staticmethod\ndef generate_geometric_benchmark_jobs(sim_size: dict[str, int], writer_args: WriterArgs) -&gt; list[WriterArgs]:\n    \"\"\"\n    Generates a list of benchmark jobs to run in parallel. Be wary of modifying the hardcoded parameters below\n    without corresponding changes to the directory structure.\n    \"\"\"\n\n    distributions = [DistType.UNIFORM, DistType.NORMAL]\n    movements = [MoveType.STATIC, MoveType.DYNAMIC]\n    los_strs = [LOSType.LOS, LOSType.NO_LOS]\n\n    job_list: list[dict[str, Any]] = []\n    # --- Write all the benchmark configs ---\n    for dist in distributions:\n        for move in movements:\n            for los in los_strs:\n                for size_name, num_agents in sim_size.items():\n                    file_name = f\"{dist}_{move}_{los}_{size_name}.json\"\n                    file_path = os.path.join(\"benchmarks\", \"geometry\", f\"{dist}_{move}_{los}\", file_name)\n                    writer_args[\"file_path\"] = file_path\n                    writer_args[\"los\"] = los\n                    writer_args[\"dist\"] = dist\n                    writer_args[\"num_agents\"] = num_agents\n                    job_list.append(copy.deepcopy(writer_args))\n    return job_list\n</code></pre>"},{"location":"reference/configuration/#configuration.BenchmarkSetup.process_objects","title":"<code>process_objects(file_path, random_seed, num_agents, speed, fov, view_range, occ_per_agent, scale, shape, targets_per_sensor, dist, los)</code>  <code>staticmethod</code>","text":"<p>This is the callable which is dispatched to the multiprocessing module. The scrip in main.py will fork the process and execute this method in the child. It takes an unpacked set of writer arguments as parameters which you can observe in the main.py file.</p> Source code in <code>configuration/benchmark_setup.py</code> <pre><code>@staticmethod\ndef process_objects(file_path: str,\n                    random_seed: int,\n                    num_agents: int,\n                    speed: float,\n                    fov: float,\n                    view_range: float,\n                    occ_per_agent: int,\n                    scale: float,\n                    shape: str,\n                    targets_per_sensor: int,\n                    dist: DistType,\n                    los: LOSType) -&gt; None:\n    \"\"\"\n    This is the callable which is dispatched to the multiprocessing module. The scrip in __main__.py will fork\n    the process and execute this method in the child. It takes an unpacked set of writer arguments as parameters\n    which you can observe in the __main__.py file.\n    \"\"\"\n\n    # --- Set the random seed ---\n    random.seed(random_seed)\n\n    # --- Build the sensor ---\n    sensor = SphericalSectorSensor(view_range=view_range, field_of_view=fov)\n\n    # --- Build the distribution from scenario ---\n    distribution_builder = DistributionBuilder(num_agents)\n    if dist == DistType.UNIFORM:\n        distribution = distribution_builder.build_uniform_from_sensor_and_targets(sensor, targets_per_sensor)\n    elif dist == DistType.NORMAL:\n        distribution = distribution_builder.build_gauss_from_sensor_and_targets(sensor, targets_per_sensor)\n    else:\n        raise NotImplementedError\n\n    # --- Make and write the Agents ---\n    agents = [Agent.random(distribution=distribution, speed=speed, sensor=sensor) for i in range(num_agents)]\n    if los == LOSType.NO_LOS:\n        SimObject.write_objects(file_path, agents=agents)\n        return\n\n    # --- Make and write the occluders ---\n    occluders = [Occluder.random(distribution=distribution, scale=scale, shape=shape) for i in range(occ_per_agent * num_agents)]\n    SimObject.write_objects(file_path, agents=agents, occluders=occluders)\n</code></pre>"},{"location":"reference/configuration/#configuration.BenchmarkSetup.set_up_benchmark_dirs","title":"<code>set_up_benchmark_dirs()</code>  <code>staticmethod</code>","text":"<p>Sets up the directory structure on the host.</p> Source code in <code>configuration/benchmark_setup.py</code> <pre><code>@staticmethod\ndef set_up_benchmark_dirs() -&gt; None:\n    \"\"\" Sets up the directory structure on the host. \"\"\"\n    for benchmark_dir in BenchmarkSetup.benchmark_dirs:\n        if not os.path.exists(benchmark_dir):\n            os.makedirs(benchmark_dir)\n</code></pre>"},{"location":"reference/geometry/","title":"Geometry Utilities","text":""},{"location":"reference/geometry/#geometry","title":"<code>geometry</code>","text":""},{"location":"reference/geometry/#geometry.Float3","title":"<code>Float3</code>  <code>dataclass</code>","text":"<p>Represents a vector-3 object, or a point in 3D space. Can do normal vector things.</p> Source code in <code>geometry/float3.py</code> <pre><code>@dataclass\nclass Float3:\n    \"\"\"\n    Represents a vector-3 object, or a point in 3D space. Can do normal vector things.\n    \"\"\"\n    x: float = 0\n    y: float = 0\n    z: float = 0\n\n    @classmethod\n    def from_uniform(cls, min_f3: 'Float3', max_f3: 'Float3') -&gt; 'Float3':\n        \"\"\" Return a random float3 from inside the given bounds. \"\"\"\n        x = random.uniform(min_f3.x, max_f3.x)\n        y = random.uniform(min_f3.y, max_f3.y)\n        z = random.uniform(min_f3.z, max_f3.z)\n        return cls(x, y, z)\n\n    @classmethod\n    def from_normal(cls, mu: 'Float3', sigma: 'Float3') -&gt; 'Float3':\n        \"\"\"\n        Return a normally distributed float3 given mean and standard deviation. Note that sigma accepts\n        a float3, so this method supports non-spherical distributions.\n        \"\"\"\n        x = random.gauss(mu.x, sigma.x)\n        y = random.gauss(mu.y, sigma.y)\n        z = random.gauss(mu.z, sigma.z)\n        return cls(x, y, z)\n\n    @classmethod\n    def point_on_unit_sphere(cls) -&gt; 'Float3':\n        \"\"\" Return a point on the unit sphere.\"\"\"\n        return cls.from_normal(cls.zero(), cls.one()).normalized()\n\n    @classmethod\n    def zero(cls) -&gt; 'Float3':\n        \"\"\" Return a zero vector. \"\"\"\n        return cls(0, 0, 0)\n\n    @classmethod\n    def one(cls) -&gt; 'Float3':\n        \"\"\" Return a one vector. \"\"\"\n        return cls(1, 1, 1)\n\n    def to_int(self) -&gt; tuple[int, int, int]:\n        \"\"\" Convert the object to an integer tuple. Useful for spatial hashing. \"\"\"\n        return int(self.x), int(self.y), int(self.z)\n\n    def __add__(self, other: 'Float3') -&gt; 'Float3':\n        \"\"\" Return the sum of two Float3. \"\"\"\n        return Float3(self.x + other.x, self.y + other.y, self.z + other.z)\n\n    def __sub__(self, other: 'Float3') -&gt; 'Float3':\n        \"\"\" Return the difference of two Float3. \"\"\"\n        return Float3(self.x - other.x, self.y - other.y, self.z - other.z)\n\n    def __floordiv__(self, other: float) -&gt; 'Float3':\n        \"\"\" Return the element-wise quotient of two Float3. \"\"\"\n        return Float3(self.x // other, self.y // other, self.z // other)\n\n    def __gt__(self, other: 'Float3') -&gt; bool:\n        \"\"\" Return true if object is strictly greater than the another float3 along all axes. \"\"\"\n        return self.x &gt; other.x and self.y &gt; other.y and self.z &gt; other.z\n\n    def __ge__(self, other: 'Float3') -&gt; bool:\n        \"\"\" Return true if object is greater than or equal to another float3 along all axes. \"\"\"\n        return self.x &gt;= other.x and self.y &gt;= other.y and self.z &gt;= other.z\n\n    def __lt__(self, other: 'Float3') -&gt; bool:\n        \"\"\" Return true if object is less than another float3 along all axes. \"\"\"\n        return self.x &lt; other.x and self.y &lt; other.y and self.z &lt; other.z\n\n    def __le__(self, other: 'Float3') -&gt; bool:\n        \"\"\" Return true if object is less than or equal to another float3 along all axes. \"\"\"\n        return self.x &lt;= other.x and self.y &lt;= other.y and self.z &lt;= other.z\n\n    def __eq__(self, other: 'Float3') -&gt; bool:\n        \"\"\" Return true if object is equal to another float3 along all axes. \"\"\"\n        return self.x == other.x and self.y == other.y and self.z == other.z\n\n    def __ne__(self, other: 'Float3') -&gt; bool:\n        \"\"\" Return true if object is not equal to another float3 along ANY axis. \"\"\"\n        return not (self == other)\n\n    def __mul__(self, other: float) -&gt; 'Float3':\n        \"\"\" Return the element-wise scalar product of a float3 with a scalar. \"\"\"\n        return Float3(self.x * other, self.y * other, self.z * other)\n\n    def dot(self, other: 'Float3') -&gt; float:\n        \"\"\" Returns the dot product of two Float3. \"\"\"\n        return self.x * other.x + self.y * other.y + self.z * other.z\n\n    def magnitude(self) -&gt; float:\n        \"\"\" Returns the magnitude of the Float3. \"\"\"\n        return math.sqrt(self.x ** 2 + self.y ** 2 + self.z ** 2)\n\n    def normalize(self) -&gt; None:\n        \"\"\" Normalizes the Float3. \"\"\"\n        mag = self.magnitude()\n        self.x /= mag\n        self.y /= mag\n        self.z /= mag\n\n    def normalized(self) -&gt; 'Float3':\n        \"\"\" Returns the normalized Float3. \"\"\"\n        mag = self.magnitude()\n        x = self.x / mag\n        y = self.y / mag\n        z = self.z / mag\n        return Float3(x, y, z)\n\n    @staticmethod\n    def distance(first: 'Float3', second: 'Float3') -&gt; float:\n        \"\"\" Returns the distance between two Float3. \"\"\"\n        return (first - second).magnitude()\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.__add__","title":"<code>__add__(other)</code>","text":"<p>Return the sum of two Float3.</p> Source code in <code>geometry/float3.py</code> <pre><code>def __add__(self, other: 'Float3') -&gt; 'Float3':\n    \"\"\" Return the sum of two Float3. \"\"\"\n    return Float3(self.x + other.x, self.y + other.y, self.z + other.z)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Return true if object is equal to another float3 along all axes.</p> Source code in <code>geometry/float3.py</code> <pre><code>def __eq__(self, other: 'Float3') -&gt; bool:\n    \"\"\" Return true if object is equal to another float3 along all axes. \"\"\"\n    return self.x == other.x and self.y == other.y and self.z == other.z\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.__floordiv__","title":"<code>__floordiv__(other)</code>","text":"<p>Return the element-wise quotient of two Float3.</p> Source code in <code>geometry/float3.py</code> <pre><code>def __floordiv__(self, other: float) -&gt; 'Float3':\n    \"\"\" Return the element-wise quotient of two Float3. \"\"\"\n    return Float3(self.x // other, self.y // other, self.z // other)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Return true if object is greater than or equal to another float3 along all axes.</p> Source code in <code>geometry/float3.py</code> <pre><code>def __ge__(self, other: 'Float3') -&gt; bool:\n    \"\"\" Return true if object is greater than or equal to another float3 along all axes. \"\"\"\n    return self.x &gt;= other.x and self.y &gt;= other.y and self.z &gt;= other.z\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Return true if object is strictly greater than the another float3 along all axes.</p> Source code in <code>geometry/float3.py</code> <pre><code>def __gt__(self, other: 'Float3') -&gt; bool:\n    \"\"\" Return true if object is strictly greater than the another float3 along all axes. \"\"\"\n    return self.x &gt; other.x and self.y &gt; other.y and self.z &gt; other.z\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.__le__","title":"<code>__le__(other)</code>","text":"<p>Return true if object is less than or equal to another float3 along all axes.</p> Source code in <code>geometry/float3.py</code> <pre><code>def __le__(self, other: 'Float3') -&gt; bool:\n    \"\"\" Return true if object is less than or equal to another float3 along all axes. \"\"\"\n    return self.x &lt;= other.x and self.y &lt;= other.y and self.z &lt;= other.z\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Return true if object is less than another float3 along all axes.</p> Source code in <code>geometry/float3.py</code> <pre><code>def __lt__(self, other: 'Float3') -&gt; bool:\n    \"\"\" Return true if object is less than another float3 along all axes. \"\"\"\n    return self.x &lt; other.x and self.y &lt; other.y and self.z &lt; other.z\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Return the element-wise scalar product of a float3 with a scalar.</p> Source code in <code>geometry/float3.py</code> <pre><code>def __mul__(self, other: float) -&gt; 'Float3':\n    \"\"\" Return the element-wise scalar product of a float3 with a scalar. \"\"\"\n    return Float3(self.x * other, self.y * other, self.z * other)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Return true if object is not equal to another float3 along ANY axis.</p> Source code in <code>geometry/float3.py</code> <pre><code>def __ne__(self, other: 'Float3') -&gt; bool:\n    \"\"\" Return true if object is not equal to another float3 along ANY axis. \"\"\"\n    return not (self == other)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Return the difference of two Float3.</p> Source code in <code>geometry/float3.py</code> <pre><code>def __sub__(self, other: 'Float3') -&gt; 'Float3':\n    \"\"\" Return the difference of two Float3. \"\"\"\n    return Float3(self.x - other.x, self.y - other.y, self.z - other.z)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.distance","title":"<code>distance(first, second)</code>  <code>staticmethod</code>","text":"<p>Returns the distance between two Float3.</p> Source code in <code>geometry/float3.py</code> <pre><code>@staticmethod\ndef distance(first: 'Float3', second: 'Float3') -&gt; float:\n    \"\"\" Returns the distance between two Float3. \"\"\"\n    return (first - second).magnitude()\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.dot","title":"<code>dot(other)</code>","text":"<p>Returns the dot product of two Float3.</p> Source code in <code>geometry/float3.py</code> <pre><code>def dot(self, other: 'Float3') -&gt; float:\n    \"\"\" Returns the dot product of two Float3. \"\"\"\n    return self.x * other.x + self.y * other.y + self.z * other.z\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.from_normal","title":"<code>from_normal(mu, sigma)</code>  <code>classmethod</code>","text":"<p>Return a normally distributed float3 given mean and standard deviation. Note that sigma accepts a float3, so this method supports non-spherical distributions.</p> Source code in <code>geometry/float3.py</code> <pre><code>@classmethod\ndef from_normal(cls, mu: 'Float3', sigma: 'Float3') -&gt; 'Float3':\n    \"\"\"\n    Return a normally distributed float3 given mean and standard deviation. Note that sigma accepts\n    a float3, so this method supports non-spherical distributions.\n    \"\"\"\n    x = random.gauss(mu.x, sigma.x)\n    y = random.gauss(mu.y, sigma.y)\n    z = random.gauss(mu.z, sigma.z)\n    return cls(x, y, z)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.from_uniform","title":"<code>from_uniform(min_f3, max_f3)</code>  <code>classmethod</code>","text":"<p>Return a random float3 from inside the given bounds.</p> Source code in <code>geometry/float3.py</code> <pre><code>@classmethod\ndef from_uniform(cls, min_f3: 'Float3', max_f3: 'Float3') -&gt; 'Float3':\n    \"\"\" Return a random float3 from inside the given bounds. \"\"\"\n    x = random.uniform(min_f3.x, max_f3.x)\n    y = random.uniform(min_f3.y, max_f3.y)\n    z = random.uniform(min_f3.z, max_f3.z)\n    return cls(x, y, z)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.magnitude","title":"<code>magnitude()</code>","text":"<p>Returns the magnitude of the Float3.</p> Source code in <code>geometry/float3.py</code> <pre><code>def magnitude(self) -&gt; float:\n    \"\"\" Returns the magnitude of the Float3. \"\"\"\n    return math.sqrt(self.x ** 2 + self.y ** 2 + self.z ** 2)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.normalize","title":"<code>normalize()</code>","text":"<p>Normalizes the Float3.</p> Source code in <code>geometry/float3.py</code> <pre><code>def normalize(self) -&gt; None:\n    \"\"\" Normalizes the Float3. \"\"\"\n    mag = self.magnitude()\n    self.x /= mag\n    self.y /= mag\n    self.z /= mag\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.normalized","title":"<code>normalized()</code>","text":"<p>Returns the normalized Float3.</p> Source code in <code>geometry/float3.py</code> <pre><code>def normalized(self) -&gt; 'Float3':\n    \"\"\" Returns the normalized Float3. \"\"\"\n    mag = self.magnitude()\n    x = self.x / mag\n    y = self.y / mag\n    z = self.z / mag\n    return Float3(x, y, z)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.one","title":"<code>one()</code>  <code>classmethod</code>","text":"<p>Return a one vector.</p> Source code in <code>geometry/float3.py</code> <pre><code>@classmethod\ndef one(cls) -&gt; 'Float3':\n    \"\"\" Return a one vector. \"\"\"\n    return cls(1, 1, 1)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.point_on_unit_sphere","title":"<code>point_on_unit_sphere()</code>  <code>classmethod</code>","text":"<p>Return a point on the unit sphere.</p> Source code in <code>geometry/float3.py</code> <pre><code>@classmethod\ndef point_on_unit_sphere(cls) -&gt; 'Float3':\n    \"\"\" Return a point on the unit sphere.\"\"\"\n    return cls.from_normal(cls.zero(), cls.one()).normalized()\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.to_int","title":"<code>to_int()</code>","text":"<p>Convert the object to an integer tuple. Useful for spatial hashing.</p> Source code in <code>geometry/float3.py</code> <pre><code>def to_int(self) -&gt; tuple[int, int, int]:\n    \"\"\" Convert the object to an integer tuple. Useful for spatial hashing. \"\"\"\n    return int(self.x), int(self.y), int(self.z)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float3.zero","title":"<code>zero()</code>  <code>classmethod</code>","text":"<p>Return a zero vector.</p> Source code in <code>geometry/float3.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; 'Float3':\n    \"\"\" Return a zero vector. \"\"\"\n    return cls(0, 0, 0)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float4","title":"<code>Float4</code>  <code>dataclass</code>","text":"<p>Represents a quaternion-like rotational transformation. Supports normal, quaternion-math with vectors (float3).</p> Source code in <code>geometry/float4.py</code> <pre><code>@dataclass\nclass Float4:\n    \"\"\"\n    Represents a quaternion-like rotational transformation. Supports normal, quaternion-math with vectors (float3).\n    \"\"\"\n    w: float = 1\n    x: float = 0\n    y: float = 0\n    z: float = 0\n\n    def __post_init__(self) -&gt; None:\n        \"\"\" Checks to ensure that magnitude is approximately equal to 1.0. \"\"\"\n        magnitude = math.sqrt(self.w**2 + self.x**2 + self.y**2 + self.z**2)\n        if not math.isclose(magnitude, 1):\n            raise ValueError(f\"Quaternions must have magnitude 1.\")\n\n    @classmethod\n    def from_theta_and_axis(cls, theta: float, axis: Float3) -&gt; 'Float4':\n        \"\"\" Return quaternion given theta and an axis. \"\"\"\n        axis = axis.normalized()\n        w = math.cos(theta / 2)\n        x = axis.x * math.sin(theta / 2)\n        y = axis.y * math.sin(theta / 2)\n        z = axis.z * math.sin(theta / 2)\n        return cls(w, x, y, z)\n\n    @classmethod\n    def from_axis(cls, axis: Float3) -&gt; 'Float4':\n        \"\"\" Returns a quaternion randomly rotated around a given axis. \"\"\"\n        theta = random.random() * 2 * math.pi\n        return cls.from_theta_and_axis(theta, axis)\n\n    @classmethod\n    def random(cls) -&gt; 'Float4':\n        \"\"\" Returns a quaternion randomly rotated around a random axis.\"\"\"\n        theta = random.random() * 2 * math.pi\n        axis = Float3.point_on_unit_sphere()\n        return cls.from_theta_and_axis(theta, axis)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float4.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Checks to ensure that magnitude is approximately equal to 1.0.</p> Source code in <code>geometry/float4.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\" Checks to ensure that magnitude is approximately equal to 1.0. \"\"\"\n    magnitude = math.sqrt(self.w**2 + self.x**2 + self.y**2 + self.z**2)\n    if not math.isclose(magnitude, 1):\n        raise ValueError(f\"Quaternions must have magnitude 1.\")\n</code></pre>"},{"location":"reference/geometry/#geometry.Float4.from_axis","title":"<code>from_axis(axis)</code>  <code>classmethod</code>","text":"<p>Returns a quaternion randomly rotated around a given axis.</p> Source code in <code>geometry/float4.py</code> <pre><code>@classmethod\ndef from_axis(cls, axis: Float3) -&gt; 'Float4':\n    \"\"\" Returns a quaternion randomly rotated around a given axis. \"\"\"\n    theta = random.random() * 2 * math.pi\n    return cls.from_theta_and_axis(theta, axis)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float4.from_theta_and_axis","title":"<code>from_theta_and_axis(theta, axis)</code>  <code>classmethod</code>","text":"<p>Return quaternion given theta and an axis.</p> Source code in <code>geometry/float4.py</code> <pre><code>@classmethod\ndef from_theta_and_axis(cls, theta: float, axis: Float3) -&gt; 'Float4':\n    \"\"\" Return quaternion given theta and an axis. \"\"\"\n    axis = axis.normalized()\n    w = math.cos(theta / 2)\n    x = axis.x * math.sin(theta / 2)\n    y = axis.y * math.sin(theta / 2)\n    z = axis.z * math.sin(theta / 2)\n    return cls(w, x, y, z)\n</code></pre>"},{"location":"reference/geometry/#geometry.Float4.random","title":"<code>random()</code>  <code>classmethod</code>","text":"<p>Returns a quaternion randomly rotated around a random axis.</p> Source code in <code>geometry/float4.py</code> <pre><code>@classmethod\ndef random(cls) -&gt; 'Float4':\n    \"\"\" Returns a quaternion randomly rotated around a random axis.\"\"\"\n    theta = random.random() * 2 * math.pi\n    axis = Float3.point_on_unit_sphere()\n    return cls.from_theta_and_axis(theta, axis)\n</code></pre>"},{"location":"reference/geometry/#geometry.AABB","title":"<code>AABB</code>  <code>dataclass</code>","text":"<p>Represents an axis aligned bounding box and holds relevant methods.</p> Source code in <code>geometry/aabb.py</code> <pre><code>@dataclass\nclass AABB:\n    \"\"\"\n    Represents an axis aligned bounding box and holds relevant methods.\n    \"\"\"\n    min_f3: Float3\n    max_f3: Float3\n\n    @classmethod\n    def empty(cls) -&gt; 'AABB':\n        \"\"\" Returns an empty AABB. \"\"\"\n        neg_inf = Float3(float(\"-inf\"), float(\"-inf\"), float(\"-inf\"))\n        pos_inf = Float3(float(\"inf\"), float(\"inf\"), float(\"inf\"))\n        return cls(pos_inf, neg_inf)\n\n    def expand_point(self, point: Float3) -&gt; None:\n        \"\"\" Expands a bounding box to include the given point. \"\"\"\n        self.min_f3.x = min(self.min_f3.x, point.x)\n        self.min_f3.y = min(self.min_f3.y, point.y)\n        self.min_f3.z = min(self.min_f3.z, point.z)\n        self.max_f3.x = max(self.max_f3.x, point.x)\n        self.max_f3.y = max(self.max_f3.y, point.y)\n        self.max_f3.z = max(self.max_f3.z, point.z)\n\n    def expand_aabb(self, aabb: 'AABB') -&gt; None:\n        \"\"\" Expands a bounding box to include the given AABB. \"\"\"\n        self.expand_point(aabb.min_f3)\n        self.expand_point(aabb.max_f3)\n\n    def dimensions(self) -&gt; Float3:\n        \"\"\" Returns the dimensions of the AABB. \"\"\"\n        return self.max_f3 - self.min_f3\n\n    def volume(self) -&gt; float:\n        \"\"\" Returns the volume of the AABB. \"\"\"\n        dims = self.dimensions()\n        return dims.dot(dims)\n</code></pre>"},{"location":"reference/geometry/#geometry.AABB.dimensions","title":"<code>dimensions()</code>","text":"<p>Returns the dimensions of the AABB.</p> Source code in <code>geometry/aabb.py</code> <pre><code>def dimensions(self) -&gt; Float3:\n    \"\"\" Returns the dimensions of the AABB. \"\"\"\n    return self.max_f3 - self.min_f3\n</code></pre>"},{"location":"reference/geometry/#geometry.AABB.empty","title":"<code>empty()</code>  <code>classmethod</code>","text":"<p>Returns an empty AABB.</p> Source code in <code>geometry/aabb.py</code> <pre><code>@classmethod\ndef empty(cls) -&gt; 'AABB':\n    \"\"\" Returns an empty AABB. \"\"\"\n    neg_inf = Float3(float(\"-inf\"), float(\"-inf\"), float(\"-inf\"))\n    pos_inf = Float3(float(\"inf\"), float(\"inf\"), float(\"inf\"))\n    return cls(pos_inf, neg_inf)\n</code></pre>"},{"location":"reference/geometry/#geometry.AABB.expand_aabb","title":"<code>expand_aabb(aabb)</code>","text":"<p>Expands a bounding box to include the given AABB.</p> Source code in <code>geometry/aabb.py</code> <pre><code>def expand_aabb(self, aabb: 'AABB') -&gt; None:\n    \"\"\" Expands a bounding box to include the given AABB. \"\"\"\n    self.expand_point(aabb.min_f3)\n    self.expand_point(aabb.max_f3)\n</code></pre>"},{"location":"reference/geometry/#geometry.AABB.expand_point","title":"<code>expand_point(point)</code>","text":"<p>Expands a bounding box to include the given point.</p> Source code in <code>geometry/aabb.py</code> <pre><code>def expand_point(self, point: Float3) -&gt; None:\n    \"\"\" Expands a bounding box to include the given point. \"\"\"\n    self.min_f3.x = min(self.min_f3.x, point.x)\n    self.min_f3.y = min(self.min_f3.y, point.y)\n    self.min_f3.z = min(self.min_f3.z, point.z)\n    self.max_f3.x = max(self.max_f3.x, point.x)\n    self.max_f3.y = max(self.max_f3.y, point.y)\n    self.max_f3.z = max(self.max_f3.z, point.z)\n</code></pre>"},{"location":"reference/geometry/#geometry.AABB.volume","title":"<code>volume()</code>","text":"<p>Returns the volume of the AABB.</p> Source code in <code>geometry/aabb.py</code> <pre><code>def volume(self) -&gt; float:\n    \"\"\" Returns the volume of the AABB. \"\"\"\n    dims = self.dimensions()\n    return dims.dot(dims)\n</code></pre>"},{"location":"reference/harness/","title":"Test Runner Documentation","text":""},{"location":"reference/harness/#test_runner","title":"<code>test_runner</code>","text":""},{"location":"reference/harness/#test_runner.BenchmarkHarness","title":"<code>BenchmarkHarness</code>","text":"<p>Orchestrates the execution of external benchmark processes. Manages configuration parsing, subprocess spawning, and log capturing.</p> Source code in <code>test_runner/harness.py</code> <pre><code>class BenchmarkHarness:\n    \"\"\"\n    Orchestrates the execution of external benchmark processes.\n    Manages configuration parsing, subprocess spawning, and log capturing.\n    \"\"\"\n    config_path: str\n    log_path: str\n    benchmark_list: list[BenchmarkArgs]\n    benchmark_results: dict[ScenarioName, BenchmarkResult]\n\n    def __init__(self, config_path: str, log_path: str):\n        self.config_path = config_path\n        self.log_path = log_path\n        self._initialize_benchmarks()\n        self._initialize_benchmark_results()\n\n    def _initialize_benchmarks(self) -&gt; None:\n        \"\"\" Parses the yaml config file and writes the benchmark jobs to a list. \"\"\"\n        yaml_dict = yaml.safe_load(open(self.config_path))\n        benchmark_args = []\n        for config_name, config_params in yaml_dict.items():\n            if config_name == \"defaults\": continue\n            if not config_params[\"run\"]: continue\n            for distribution in config_params[\"distributions\"]:\n                directory = os.path.join(os.getcwd(), \"benchmarks\", \"geometry\", f\"{distribution}_{config_name}\")\n                for size, num_updates in config_params[\"sizes\"].items():\n                    clargs = dict()\n                    file_name = f\"{distribution}_{config_name}_{size}.json\"\n                    file_path = os.path.join(directory, file_name)\n                    clargs[\"executable\"] = config_params[\"executable\"]\n                    clargs[\"-scenarioPath\"] = file_path\n                    clargs[\"-scenarioName\"] = file_name\n                    clargs[\"-numUpdates\"] = str(num_updates)\n                    clargs = clargs | config_params[\"clargs\"]\n                    benchmark_args.append(clargs)\n        self.benchmark_list = benchmark_args\n\n\n    def _initialize_benchmark_results(self) -&gt; None:\n        \"\"\" Initialize the benchmark results dictionary with unexecuted benchmark jobs. \"\"\"\n        self.benchmark_results = dict()\n        for benchmark in self.benchmark_list:\n            self.benchmark_results[benchmark[\"-scenarioName\"]] = (\n                BenchmarkResult(result=-1,\n                                start_time=-1,\n                                time_elapsed=-1,\n                                status=\"Not Started\",\n                                num_iterations=int(benchmark[\"-numUpdates\"]),\n                                correct=\"N/A\"))\n\n\n    def run_benchmark(self, clargs: BenchmarkArgs) -&gt; None:\n        \"\"\"\n        This method does a few things. Most importantly, it forks and executes the benchmark run with the provided BenchmarkArgs.\n        When it forks the process with the subprocess module, it sets up a pipe to intercept standard output from the child process.\n        It blocks on that pipe, and waits for appropriate flags in order to start and stop a timer, and parse the actual result.\n\n        Finally, it takes the measured wall clock time and writes it (along with some other data) to the benchmark_results dictionary.\n        This looks a bit indirect (why not just return a dictionary entry). But it ends up being much easier to modify the dictionary\n        in place to support the visual feedback in the terminal UI by doing it this way.\n        \"\"\"\n        scenario_name = clargs[\"-scenarioName\"]\n        clargs_list = list()\n        clargs_list.append(clargs[\"executable\"])\n        for specifier, arg in clargs.items():\n            if specifier in \"executable\":\n                continue\n            clargs_list.append(specifier)\n            if arg:\n                clargs_list.append(arg)\n\n        process = subprocess.Popen(clargs_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True,\n                                   encoding=\"utf-8\")\n        self.benchmark_results[scenario_name].start_time = time.perf_counter()\n\n        start_time = 0.0\n        end_time = 0.0\n        result = None\n\n        with open(self.log_path, \"a\") as log:\n            for line in process.stdout:\n                if \"### START BENCHMARK ###\" in line:\n                    start_time = time.perf_counter()\n                elif \"### END BENCHMARK ###\" in line:\n                    end_time = time.perf_counter()\n                elif \"### QUERY RESULT\" in line:\n                    try:\n                        result = int(line.split(\"|\")[1])\n                    except (IndexError, ValueError):\n                        pass\n                log.write(line)\n                log.flush()\n\n        stderr_output = process.stderr.read()\n        if stderr_output:\n            print(\"\\n--- ERRORS ---\")\n            print(stderr_output)\n            print(\"--------------\")\n\n        process.terminate()\n        self.benchmark_results[scenario_name].time_elapsed = end_time - start_time\n        self.benchmark_results[scenario_name].result = result\n        self.benchmark_results[scenario_name].correct = \"true\"\n\n\n    def write_log_heading(self) -&gt; None:\n        \"\"\" Writes a log heading. \"\"\"\n        with open(self.log_path, \"w\") as log:\n            log.write(\"######################################################\\n\")\n            log.write(\"################## BENCHMARK LOGS ####################\\n\")\n            log.write(\"######################################################\\n\")\n            log.write(\"------------------------------------------------------\\n\")\n\n\n    def write_benchmark_heading(self, scenario_name: str) -&gt; None:\n        \"\"\" Writes an individual benchmark heading. \"\"\"\n        with open(self.log_path, \"a\") as log:\n            log.write(\"######################################################\\n\")\n            log.write(f\"### BENCHMARK FOR: {scenario_name}\\n\")\n            log.write(\"######################################################\\n\")\n</code></pre>"},{"location":"reference/harness/#test_runner.BenchmarkHarness.run_benchmark","title":"<code>run_benchmark(clargs)</code>","text":"<p>This method does a few things. Most importantly, it forks and executes the benchmark run with the provided BenchmarkArgs. When it forks the process with the subprocess module, it sets up a pipe to intercept standard output from the child process. It blocks on that pipe, and waits for appropriate flags in order to start and stop a timer, and parse the actual result.</p> <p>Finally, it takes the measured wall clock time and writes it (along with some other data) to the benchmark_results dictionary. This looks a bit indirect (why not just return a dictionary entry). But it ends up being much easier to modify the dictionary in place to support the visual feedback in the terminal UI by doing it this way.</p> Source code in <code>test_runner/harness.py</code> <pre><code>def run_benchmark(self, clargs: BenchmarkArgs) -&gt; None:\n    \"\"\"\n    This method does a few things. Most importantly, it forks and executes the benchmark run with the provided BenchmarkArgs.\n    When it forks the process with the subprocess module, it sets up a pipe to intercept standard output from the child process.\n    It blocks on that pipe, and waits for appropriate flags in order to start and stop a timer, and parse the actual result.\n\n    Finally, it takes the measured wall clock time and writes it (along with some other data) to the benchmark_results dictionary.\n    This looks a bit indirect (why not just return a dictionary entry). But it ends up being much easier to modify the dictionary\n    in place to support the visual feedback in the terminal UI by doing it this way.\n    \"\"\"\n    scenario_name = clargs[\"-scenarioName\"]\n    clargs_list = list()\n    clargs_list.append(clargs[\"executable\"])\n    for specifier, arg in clargs.items():\n        if specifier in \"executable\":\n            continue\n        clargs_list.append(specifier)\n        if arg:\n            clargs_list.append(arg)\n\n    process = subprocess.Popen(clargs_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True,\n                               encoding=\"utf-8\")\n    self.benchmark_results[scenario_name].start_time = time.perf_counter()\n\n    start_time = 0.0\n    end_time = 0.0\n    result = None\n\n    with open(self.log_path, \"a\") as log:\n        for line in process.stdout:\n            if \"### START BENCHMARK ###\" in line:\n                start_time = time.perf_counter()\n            elif \"### END BENCHMARK ###\" in line:\n                end_time = time.perf_counter()\n            elif \"### QUERY RESULT\" in line:\n                try:\n                    result = int(line.split(\"|\")[1])\n                except (IndexError, ValueError):\n                    pass\n            log.write(line)\n            log.flush()\n\n    stderr_output = process.stderr.read()\n    if stderr_output:\n        print(\"\\n--- ERRORS ---\")\n        print(stderr_output)\n        print(\"--------------\")\n\n    process.terminate()\n    self.benchmark_results[scenario_name].time_elapsed = end_time - start_time\n    self.benchmark_results[scenario_name].result = result\n    self.benchmark_results[scenario_name].correct = \"true\"\n</code></pre>"},{"location":"reference/harness/#test_runner.BenchmarkHarness.write_benchmark_heading","title":"<code>write_benchmark_heading(scenario_name)</code>","text":"<p>Writes an individual benchmark heading.</p> Source code in <code>test_runner/harness.py</code> <pre><code>def write_benchmark_heading(self, scenario_name: str) -&gt; None:\n    \"\"\" Writes an individual benchmark heading. \"\"\"\n    with open(self.log_path, \"a\") as log:\n        log.write(\"######################################################\\n\")\n        log.write(f\"### BENCHMARK FOR: {scenario_name}\\n\")\n        log.write(\"######################################################\\n\")\n</code></pre>"},{"location":"reference/harness/#test_runner.BenchmarkHarness.write_log_heading","title":"<code>write_log_heading()</code>","text":"<p>Writes a log heading.</p> Source code in <code>test_runner/harness.py</code> <pre><code>def write_log_heading(self) -&gt; None:\n    \"\"\" Writes a log heading. \"\"\"\n    with open(self.log_path, \"w\") as log:\n        log.write(\"######################################################\\n\")\n        log.write(\"################## BENCHMARK LOGS ####################\\n\")\n        log.write(\"######################################################\\n\")\n        log.write(\"------------------------------------------------------\\n\")\n</code></pre>"},{"location":"reference/harness/#test_runner.BenchmarkResult","title":"<code>BenchmarkResult</code>  <code>dataclass</code>","text":"<p>Simply defines a benchmark result object.</p> Source code in <code>test_runner/benchmark_result.py</code> <pre><code>@dataclass\nclass BenchmarkResult:\n    \"\"\" Simply defines a benchmark result object. \"\"\"\n    result: int\n    num_iterations: int\n    start_time: float\n    time_elapsed: float\n    status: str\n    correct: str\n</code></pre>"},{"location":"reference/sim_objects/","title":"Simulation Object Documentation","text":""},{"location":"reference/sim_objects/#sim_objects","title":"<code>sim_objects</code>","text":""},{"location":"reference/sim_objects/#sim_objects.SimObject","title":"<code>SimObject</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for simulation objects.</p> Source code in <code>sim_objects/base.py</code> <pre><code>@dataclass\nclass SimObject(ABC):\n    \"\"\" Abstract base class for simulation objects. \"\"\"\n    type: str\n    position: Float3\n    rotation: Float4\n    random_seed: int\n\n    @abstractmethod\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\" Returns a dictionary representation of the object. \"\"\"\n        pass\n\n    @staticmethod\n    def write_objects(filename: str, **entity_lists) -&gt; None:\n        \"\"\"\n        Writes objects to a json file. Note that this method is a static method which writes a *list*\n        of objects. It does not write self. We do this so that we can exploit the nested capabilities of json.dumps,\n        since ultimately we'll be writing a list of objects, not a single instance. Strictly, this could and should\n        probably be in its own class.\n        \"\"\"\n        json_dict = dict()\n        for name, entity_list in entity_lists.items():\n            json_dict[name] = [entity.to_dict() for entity in entity_list]\n        with open(filename, 'w') as file:\n            json.dump(json_dict, file, indent=4)\n</code></pre>"},{"location":"reference/sim_objects/#sim_objects.SimObject.to_dict","title":"<code>to_dict()</code>  <code>abstractmethod</code>","text":"<p>Returns a dictionary representation of the object.</p> Source code in <code>sim_objects/base.py</code> <pre><code>@abstractmethod\ndef to_dict(self) -&gt; dict[str, Any]:\n    \"\"\" Returns a dictionary representation of the object. \"\"\"\n    pass\n</code></pre>"},{"location":"reference/sim_objects/#sim_objects.SimObject.write_objects","title":"<code>write_objects(filename, **entity_lists)</code>  <code>staticmethod</code>","text":"<p>Writes objects to a json file. Note that this method is a static method which writes a list of objects. It does not write self. We do this so that we can exploit the nested capabilities of json.dumps, since ultimately we'll be writing a list of objects, not a single instance. Strictly, this could and should probably be in its own class.</p> Source code in <code>sim_objects/base.py</code> <pre><code>@staticmethod\ndef write_objects(filename: str, **entity_lists) -&gt; None:\n    \"\"\"\n    Writes objects to a json file. Note that this method is a static method which writes a *list*\n    of objects. It does not write self. We do this so that we can exploit the nested capabilities of json.dumps,\n    since ultimately we'll be writing a list of objects, not a single instance. Strictly, this could and should\n    probably be in its own class.\n    \"\"\"\n    json_dict = dict()\n    for name, entity_list in entity_lists.items():\n        json_dict[name] = [entity.to_dict() for entity in entity_list]\n    with open(filename, 'w') as file:\n        json.dump(json_dict, file, indent=4)\n</code></pre>"},{"location":"reference/sim_objects/#sim_objects.Agent","title":"<code>Agent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SimObject</code></p> <p>Represents an agent in the simulation.</p> Source code in <code>sim_objects/agent.py</code> <pre><code>@dataclass\nclass Agent(SimObject):\n    \"\"\" Represents an agent in the simulation. \"\"\"\n    speed: float\n    sensor: Sensor\n\n    @classmethod\n    def random(cls, distribution: SpatialDistribution, speed: float, sensor: Sensor) -&gt; 'Agent':\n        \"\"\" Creates a random agent in the simulation drawn from the given distribution. \"\"\"\n        position = distribution.get_float3()\n        look_direction = Float3.point_on_unit_sphere()\n        rotation = Float4.from_axis(look_direction)\n        random_seed = random.randint(0, 1000000000)\n        new_sensor = deepcopy(sensor)\n        new_sensor.look_direction = look_direction\n        return cls(\"agent\", position, rotation, random_seed, speed, new_sensor)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\" Returns a dictionary representation of the agent. Flattens sensor data to satisfy standard json interface. \"\"\"\n        data = asdict(self)\n        sensor_data = data.pop(\"sensor\")\n        return {**data, **sensor_data}\n</code></pre>"},{"location":"reference/sim_objects/#sim_objects.Agent.random","title":"<code>random(distribution, speed, sensor)</code>  <code>classmethod</code>","text":"<p>Creates a random agent in the simulation drawn from the given distribution.</p> Source code in <code>sim_objects/agent.py</code> <pre><code>@classmethod\ndef random(cls, distribution: SpatialDistribution, speed: float, sensor: Sensor) -&gt; 'Agent':\n    \"\"\" Creates a random agent in the simulation drawn from the given distribution. \"\"\"\n    position = distribution.get_float3()\n    look_direction = Float3.point_on_unit_sphere()\n    rotation = Float4.from_axis(look_direction)\n    random_seed = random.randint(0, 1000000000)\n    new_sensor = deepcopy(sensor)\n    new_sensor.look_direction = look_direction\n    return cls(\"agent\", position, rotation, random_seed, speed, new_sensor)\n</code></pre>"},{"location":"reference/sim_objects/#sim_objects.Agent.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns a dictionary representation of the agent. Flattens sensor data to satisfy standard json interface.</p> Source code in <code>sim_objects/agent.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\" Returns a dictionary representation of the agent. Flattens sensor data to satisfy standard json interface. \"\"\"\n    data = asdict(self)\n    sensor_data = data.pop(\"sensor\")\n    return {**data, **sensor_data}\n</code></pre>"},{"location":"reference/sim_objects/#sim_objects.Occluder","title":"<code>Occluder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SimObject</code></p> <p>Represents a piece of static geometry which occludes line of sight checks.</p> Source code in <code>sim_objects/occluder.py</code> <pre><code>@dataclass\nclass Occluder(SimObject):\n    \"\"\" Represents a piece of static geometry which occludes line of sight checks. \"\"\"\n    scale: float\n    shape: str\n\n    @classmethod\n    def random(cls, distribution: SpatialDistribution, scale: float, shape: str) -&gt; 'Occluder':\n        \"\"\" Generate a random occluder from the given distribution. \"\"\"\n        position = distribution.get_float3()\n        orientation = Float3.point_on_unit_sphere()\n        rotation = Float4.from_axis(orientation)\n        random_seed = random.randint(0, 1000000000)\n        return cls(\"occluder\", position, rotation, random_seed, scale, shape)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\" Returns a dict representation of the object. \"\"\"\n        return asdict(self)\n</code></pre>"},{"location":"reference/sim_objects/#sim_objects.Occluder.random","title":"<code>random(distribution, scale, shape)</code>  <code>classmethod</code>","text":"<p>Generate a random occluder from the given distribution.</p> Source code in <code>sim_objects/occluder.py</code> <pre><code>@classmethod\ndef random(cls, distribution: SpatialDistribution, scale: float, shape: str) -&gt; 'Occluder':\n    \"\"\" Generate a random occluder from the given distribution. \"\"\"\n    position = distribution.get_float3()\n    orientation = Float3.point_on_unit_sphere()\n    rotation = Float4.from_axis(orientation)\n    random_seed = random.randint(0, 1000000000)\n    return cls(\"occluder\", position, rotation, random_seed, scale, shape)\n</code></pre>"},{"location":"reference/sim_objects/#sim_objects.Occluder.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns a dict representation of the object.</p> Source code in <code>sim_objects/occluder.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\" Returns a dict representation of the object. \"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"reference/sim_objects/#sim_objects.Sensor","title":"<code>Sensor</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract sensor class. Must have an orientation.</p> Source code in <code>sim_objects/sensor.py</code> <pre><code>@dataclass(kw_only=True)\nclass Sensor(ABC):\n    \"\"\" Abstract sensor class. Must have an orientation. \"\"\"\n    look_direction: Float3 = field(default_factory=Float3.zero)\n\n    @property\n    @abstractmethod\n    def volume(self):\n        pass\n</code></pre>"},{"location":"reference/sim_objects/#sim_objects.SphericalSectorSensor","title":"<code>SphericalSectorSensor</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Sensor</code></p> <p>Represents a spherical sector sensor. In a piece of simulation software, this can be queries via a sphere overlap query and dot product check.</p> Source code in <code>sim_objects/sensor.py</code> <pre><code>@dataclass(kw_only=True)\nclass SphericalSectorSensor(Sensor):\n    \"\"\"\n    Represents a spherical sector sensor. In a piece of simulation software, this can be queries via\n    a sphere overlap query and dot product check.\n    \"\"\"\n    field_of_view: float\n    view_range: float\n\n    @property\n    def volume(self):\n        \"\"\" Returns the volume of the spherical sector. \"\"\"\n        fov_half_angle = math.radians(self.field_of_view / 2.0)\n        sphere_fraction = (1 - math.cos(fov_half_angle)) / 2.0\n        sphere_volume = (4.0 / 3.0) * math.pi * self.view_range ** 3\n        sensor_volume = sphere_volume * sphere_fraction\n        return sensor_volume\n</code></pre>"},{"location":"reference/sim_objects/#sim_objects.SphericalSectorSensor.volume","title":"<code>volume</code>  <code>property</code>","text":"<p>Returns the volume of the spherical sector.</p>"},{"location":"reference/utils/","title":"Distribution Utilities","text":""},{"location":"reference/utils/#utils","title":"<code>utils</code>","text":""},{"location":"reference/utils/#utils.DistributionBuilder","title":"<code>DistributionBuilder</code>  <code>dataclass</code>","text":"<p>Represents a spatial distribution factory.</p> Source code in <code>utils/distribution_builder.py</code> <pre><code>@dataclass\nclass DistributionBuilder:\n    \"\"\" Represents a spatial distribution factory. \"\"\"\n    num_agents: int\n\n    def build_gauss_from_sensor_and_targets(self, sensor: Sensor, targets_per_sensor: int) -&gt; GaussianSpatialDistribution:\n        \"\"\" Builds a Gaussian distribution from a sensor and targets. \"\"\"\n        scaling_factor = self._sigma(sensor, targets_per_sensor)\n        mu = Float3.zero()\n        sigma = Float3.one() * scaling_factor\n        return GaussianSpatialDistribution(mu, sigma)\n\n    def build_uniform_from_sensor_and_targets(self, sensor: Sensor, targets_per_sensor: int) -&gt; UniformSpatialDistribution:\n        \"\"\" Builds a Uniform distribution from a sensor and targets. \"\"\"\n        desired_density = targets_per_sensor / sensor.volume\n        desired_world_volume = self.num_agents / desired_density\n        desired_world_dimensions = desired_world_volume ** (1.0 / 3.0)\n        coord = desired_world_dimensions / 2\n        min_f3 = Float3(-coord, -coord, -coord)\n        max_f3 = Float3(coord, coord, coord)\n        return UniformSpatialDistribution(min_f3, max_f3)\n\n    def _sigma(self, sensor: Sensor, targets_per_sensor: int) -&gt; float:\n        \"\"\" Calculates appropriate sigma from sensor volume and targets. \"\"\"\n        return (self.num_agents * sensor.volume / targets_per_sensor) ** (1.0 / 3.0) / math.pi\n</code></pre>"},{"location":"reference/utils/#utils.DistributionBuilder.build_gauss_from_sensor_and_targets","title":"<code>build_gauss_from_sensor_and_targets(sensor, targets_per_sensor)</code>","text":"<p>Builds a Gaussian distribution from a sensor and targets.</p> Source code in <code>utils/distribution_builder.py</code> <pre><code>def build_gauss_from_sensor_and_targets(self, sensor: Sensor, targets_per_sensor: int) -&gt; GaussianSpatialDistribution:\n    \"\"\" Builds a Gaussian distribution from a sensor and targets. \"\"\"\n    scaling_factor = self._sigma(sensor, targets_per_sensor)\n    mu = Float3.zero()\n    sigma = Float3.one() * scaling_factor\n    return GaussianSpatialDistribution(mu, sigma)\n</code></pre>"},{"location":"reference/utils/#utils.DistributionBuilder.build_uniform_from_sensor_and_targets","title":"<code>build_uniform_from_sensor_and_targets(sensor, targets_per_sensor)</code>","text":"<p>Builds a Uniform distribution from a sensor and targets.</p> Source code in <code>utils/distribution_builder.py</code> <pre><code>def build_uniform_from_sensor_and_targets(self, sensor: Sensor, targets_per_sensor: int) -&gt; UniformSpatialDistribution:\n    \"\"\" Builds a Uniform distribution from a sensor and targets. \"\"\"\n    desired_density = targets_per_sensor / sensor.volume\n    desired_world_volume = self.num_agents / desired_density\n    desired_world_dimensions = desired_world_volume ** (1.0 / 3.0)\n    coord = desired_world_dimensions / 2\n    min_f3 = Float3(-coord, -coord, -coord)\n    max_f3 = Float3(coord, coord, coord)\n    return UniformSpatialDistribution(min_f3, max_f3)\n</code></pre>"},{"location":"reference/utils/#utils.SpatialDistribution","title":"<code>SpatialDistribution</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class to implement spatial distributions.</p> Source code in <code>utils/distributions.py</code> <pre><code>class SpatialDistribution(ABC):\n    \"\"\" Abstract class to implement spatial distributions. \"\"\"\n    @abstractmethod\n    def get_float3(self) -&gt; Float3:\n        pass\n</code></pre>"},{"location":"reference/utils/#utils.UniformSpatialDistribution","title":"<code>UniformSpatialDistribution</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SpatialDistribution</code></p> <p>A uniform spatial distribution.</p> Source code in <code>utils/distributions.py</code> <pre><code>@dataclass\nclass UniformSpatialDistribution(SpatialDistribution):\n    \"\"\" A uniform spatial distribution. \"\"\"\n    min_f3: Float3\n    max_f3: Float3\n\n    def get_float3(self) -&gt; Float3:\n        \"\"\" Generates the next float3 from the uniform distribution. \"\"\"\n        x = random.uniform(self.min_f3.x, self.max_f3.x)\n        y = random.uniform(self.min_f3.y, self.max_f3.y)\n        z = random.uniform(self.min_f3.z, self.max_f3.z)\n        return Float3(x, y, z)\n</code></pre>"},{"location":"reference/utils/#utils.UniformSpatialDistribution.get_float3","title":"<code>get_float3()</code>","text":"<p>Generates the next float3 from the uniform distribution.</p> Source code in <code>utils/distributions.py</code> <pre><code>def get_float3(self) -&gt; Float3:\n    \"\"\" Generates the next float3 from the uniform distribution. \"\"\"\n    x = random.uniform(self.min_f3.x, self.max_f3.x)\n    y = random.uniform(self.min_f3.y, self.max_f3.y)\n    z = random.uniform(self.min_f3.z, self.max_f3.z)\n    return Float3(x, y, z)\n</code></pre>"},{"location":"reference/utils/#utils.GaussianSpatialDistribution","title":"<code>GaussianSpatialDistribution</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SpatialDistribution</code></p> <p>A gaussian spatial distribution.</p> Source code in <code>utils/distributions.py</code> <pre><code>@dataclass\nclass GaussianSpatialDistribution(SpatialDistribution):\n    \"\"\" A gaussian spatial distribution. \"\"\"\n    mu: Float3\n    sigma: Float3\n\n    def get_float3(self) -&gt; Float3:\n        \"\"\" Generates the next float3 from the gaussian distribution. \"\"\"\n        x = random.gauss(self.mu.x, self.sigma.x)\n        y = random.gauss(self.mu.y, self.sigma.y)\n        z = random.gauss(self.mu.z, self.sigma.z)\n        return Float3(x, y, z)\n</code></pre>"},{"location":"reference/utils/#utils.GaussianSpatialDistribution.get_float3","title":"<code>get_float3()</code>","text":"<p>Generates the next float3 from the gaussian distribution.</p> Source code in <code>utils/distributions.py</code> <pre><code>def get_float3(self) -&gt; Float3:\n    \"\"\" Generates the next float3 from the gaussian distribution. \"\"\"\n    x = random.gauss(self.mu.x, self.sigma.x)\n    y = random.gauss(self.mu.y, self.sigma.y)\n    z = random.gauss(self.mu.z, self.sigma.z)\n    return Float3(x, y, z)\n</code></pre>"}]}